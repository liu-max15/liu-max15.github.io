<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">

    

    <title>
      CF914D Bash and a Tough Math Puzzle题解 | PrincessYR&#39;blog 
    </title>

    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    
      <meta name="author" content="John Doe">
    
    

    <meta name="description" content="题面 这是一道线段树的模板题，外加找最大公约数。 先来讲一下线段树哦：  建树：  先来看一下线段树长啥样  （注：图片来自百度百科） 最下面一层是我们要读入的数组a[i]。 我们从顶端开始建树，根据二叉树的性质我们可以知道一棵树的左儿子的序号为父亲的序号乘二，右儿子为乘二加一。 我们一直往下递推，知道左端点等于右端点，及一个区间只包含一个数。及搜到最后一层，我们便将a数组的只赋给线段树，当回到父">
<meta property="og:type" content="article">
<meta property="og:title" content="CF914D Bash and a Tough Math Puzzle题解 | PrincessYR&#39;blog">
<meta property="og:url" content="http://yoursite.com/2020/04/16/CF914D-Bash-and-a-Tough-Math-Puzzle%E9%A2%98%E8%A7%A3/index.html">
<meta property="og:site_name" content="PrincessYR&#39;blog">
<meta property="og:description" content="题面 这是一道线段树的模板题，外加找最大公约数。 先来讲一下线段树哦：  建树：  先来看一下线段树长啥样  （注：图片来自百度百科） 最下面一层是我们要读入的数组a[i]。 我们从顶端开始建树，根据二叉树的性质我们可以知道一棵树的左儿子的序号为父亲的序号乘二，右儿子为乘二加一。 我们一直往下递推，知道左端点等于右端点，及一个区间只包含一个数。及搜到最后一层，我们便将a数组的只赋给线段树，当回到父">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://bkimg.cdn.bcebos.com/pic/bd3eb13533fa828bcb5fe85ffe1f4134970a5a09?x-bce-process=image/watermark,g_7,image_d2F0ZXIvYmFpa2U5Mg==,xp_5,yp_5">
<meta property="article:published_time" content="2020-04-16T03:14:46.000Z">
<meta property="article:modified_time" content="2020-04-16T03:15:56.900Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="线段树">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://bkimg.cdn.bcebos.com/pic/bd3eb13533fa828bcb5fe85ffe1f4134970a5a09?x-bce-process=image/watermark,g_7,image_d2F0ZXIvYmFpa2U5Mg==,xp_5,yp_5">
    
    
    
      <link rel="icon" type="image/x-icon" href="/favicon.png">
    
    
<link rel="stylesheet" href="/css/uno.css">

    
<link rel="stylesheet" href="/css/highlight.css">

    
<link rel="stylesheet" href="/css/archive.css">

    
<link rel="stylesheet" href="/css/china-social-icon.css">


<meta name="generator" content="Hexo 4.2.0"></head>
<body>

    <span class="mobile btn-mobile-menu">
        <i class="icon icon-list btn-mobile-menu__icon"></i>
        <i class="icon icon-x-circle btn-mobile-close__icon hidden"></i>
    </span>

    

<header class="panel-cover panel-cover--collapsed">


  <div class="panel-main">

  
    <div class="panel-main__inner panel-inverted">
    <div class="panel-main__content">

        

        <h1 class="panel-cover__title panel-title"><a href="/" title="link to homepage">PrincessYR&#39;blog</a></h1>
        <hr class="panel-cover__divider" />

        

        <div class="navigation-wrapper">

          <nav class="cover-navigation cover-navigation--primary">
            <ul class="navigation">

              
                
                <li class="navigation__item"><a href="/#blog" title="" class="blog-button">首页</a></li>
              
                
                <li class="navigation__item"><a href="/about" title="" class="">关于</a></li>
              
                
                <li class="navigation__item"><a href="/archive" title="" class="">归档</a></li>
              

            </ul>
          </nav>

          <!-- ----------------------------
To add a new social icon simply duplicate one of the list items from below
and change the class in the <i> tag to match the desired social network
and then add your link to the <a>. Here is a full list of social network
classes that you can use:

    icon-social-500px
    icon-social-behance
    icon-social-delicious
    icon-social-designer-news
    icon-social-deviant-art
    icon-social-digg
    icon-social-dribbble
    icon-social-facebook
    icon-social-flickr
    icon-social-forrst
    icon-social-foursquare
    icon-social-github
    icon-social-google-plus
    icon-social-hi5
    icon-social-instagram
    icon-social-lastfm
    icon-social-linkedin
    icon-social-medium
    icon-social-myspace
    icon-social-path
    icon-social-pinterest
    icon-social-rdio
    icon-social-reddit
    icon-social-skype
    icon-social-spotify
    icon-social-stack-overflow
    icon-social-steam
    icon-social-stumbleupon
    icon-social-treehouse
    icon-social-tumblr
    icon-social-twitter
    icon-social-vimeo
    icon-social-xbox
    icon-social-yelp
    icon-social-youtube
    icon-social-zerply
    icon-mail

-------------------------------->

<!-- add social info here -->



        </div>

      </div>

    </div>

    <div class="panel-cover--overlay"></div>
  </div>
</header>

    <div class="content-wrapper">
        <div class="content-wrapper__inner entry">
            

<article class="post-container post-container--single">

  <header class="post-header">
    
    <h1 class="post-title">CF914D Bash and a Tough Math Puzzle题解</h1>

    

    <div class="post-meta">
      <time datetime="2020-04-16" class="post-meta__date date">2020-04-16</time> 

      <span class="post-meta__tags tags">

          

          
             &#8226; 标签:
            <font class="tags">
              <a class="tags-link" href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" rel="tag">线段树</a>
            </font>
          

      </span>
    </div>
    
    

  </header>

  <section id="post-content" class="article-content post">
    <p><a href="https://codeforces.com/problemset/problem/914/D" target="_blank" rel="noopener">题面</a></p>
<p>这是一道线段树的模板题，外加找最大公约数。</p>
<p>先来讲一下线段树哦：</p>
<ol>
<li>建树：</li>
</ol>
<p>先来看一下线段树长啥样</p>
<p><img src="https://bkimg.cdn.bcebos.com/pic/bd3eb13533fa828bcb5fe85ffe1f4134970a5a09?x-bce-process=image/watermark,g_7,image_d2F0ZXIvYmFpa2U5Mg==,xp_5,yp_5" alt=""></p>
<p>（注：图片来自百度百科）</p>
<p>最下面一层是我们要读入的数组a[i]。</p>
<p>我们从顶端开始建树，根据二叉树的性质我们可以知道一棵树的左儿子的序号为父亲的序号乘二，右儿子为乘二加一。</p>
<p>我们一直往下递推，知道左端点等于右端点，及一个区间只包含一个数。及搜到最后一层，我们便将a数组的只赋给线段树，当回到父节点是在根据需要判断。</p>
<p>例如这道题要求最小值，我们使父亲节点取字节点的最小值（如果求和，则将子节点的值加起来）。</p>
<p>建树代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">void build(int k,int l,int r)&#x2F;&#x2F;k为结点编号，l为区间的左端，r为右端</span><br><span class="line">&#123;</span><br><span class="line">	lazy[k]&#x3D;0;</span><br><span class="line">	if(l&#x3D;&#x3D;r)</span><br><span class="line">	&#123;</span><br><span class="line">		sum[k]&#x3D;a[l];</span><br><span class="line">		return ;</span><br><span class="line">	&#125;</span><br><span class="line">	int mid&#x3D;(l+r)&#x2F;2;</span><br><span class="line">	build(k*2,l,mid);</span><br><span class="line">	build(k*2+1,mid+1,r);</span><br><span class="line">	sum[k]&#x3D;min(sum[k*2],sum[k*2+1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果求和：</p>
<p>我们只需要在最开始时将</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sum[k]&#x3D;min(sum[k*2],sum[k*2+1]);</span><br></pre></td></tr></table></figure>

<p>中的等式右边改为自己想要的即可</p>
<p>在这道题中只让我们求最大公约数，所以，我们sum就存最大公约数，具体讲解在下方。</p>
<ol start="2">
<li>加减标记：</li>
</ol>
<p>一般来说加减就一直搜，将所有点都改一遍。然而这样时间复杂度十分高，十分容易超时。</p>
<p>那么我们就引入了懒惰标记，lazy。</p>
<p>lazy就是将我们要更改的只存储起来，不向下传，等到什么时候要求这个区间的值时，再将值更改。</p>
<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">void pushdown(int k)</span><br><span class="line">&#123;</span><br><span class="line">	lazy[k*2]+&#x3D;lazy[k];&#x2F;&#x2F;将lazy传给左儿子</span><br><span class="line">	lazy[k*2+1]+&#x3D;lazy[k];&#x2F;&#x2F;将lazy传给右儿子</span><br><span class="line">	sum[k*2]+&#x3D;lazy[k];&#x2F;&#x2F;左儿子加上lazy</span><br><span class="line">	sum[k*2+1]+&#x3D;lazy[k];&#x2F;&#x2F;右儿子加上lazy</span><br><span class="line">	lazy[k]&#x3D;0;&#x2F;&#x2F;将父亲节点的lazy清零</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void gx(int L,int R,int e,int l,int r,int k)</span><br><span class="line">&#123;</span><br><span class="line">	if(L&lt;&#x3D;l&amp;&amp;R&gt;&#x3D;r)&#x2F;&#x2F;如果当前查询的区间完全包含在内</span><br><span class="line">	&#123;</span><br><span class="line">		lazy[k]+&#x3D;e;&#x2F;&#x2F;lazy记录</span><br><span class="line">		sum[k]+&#x3D;e;&#x2F;&#x2F;当前节点加e</span><br><span class="line">		return ; </span><br><span class="line">	&#125;</span><br><span class="line">	pushdown(k);&#x2F;&#x2F;将lazy传给子节点</span><br><span class="line">	int mid&#x3D;(l+r)&#x2F;2;</span><br><span class="line">	if(L&lt;&#x3D;mid)&#x2F;&#x2F;如果左节点有要查询的值</span><br><span class="line">	&#123;</span><br><span class="line">		gx(L,R,e,l,mid,k*2);&#x2F;&#x2F;查询左边</span><br><span class="line">	&#125;</span><br><span class="line">	if(mid&lt;R)&#x2F;&#x2F;如果右节点有要查询的值</span><br><span class="line">	&#123;</span><br><span class="line">		gx(L,R,e,mid+1,r,k*2+1);&#x2F;&#x2F;查询右边的值</span><br><span class="line">	&#125;</span><br><span class="line">	sum[k]&#x3D;min(sum[k*2],sum[k*2+1]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>最小值查询：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">int qh(long k,int l,int r,int L,int R)&#x2F;&#x2F;注意，本代码中sum求的是最小值</span><br><span class="line">&#123;</span><br><span class="line">	if(L&lt;&#x3D;l&amp;&amp;R&gt;&#x3D;r)&#x2F;&#x2F;如果包含在内，直接返回最小值</span><br><span class="line">	&#123;</span><br><span class="line">		return sum[k];</span><br><span class="line">	&#125;</span><br><span class="line">	else </span><br><span class="line">	&#123;</span><br><span class="line">		pushdown(k);&#x2F;&#x2F;更新子节点，将lazy下传</span><br><span class="line">		long long re&#x3D;2147483647485;</span><br><span class="line">		int mid&#x3D;(l+r)&#x2F;2;</span><br><span class="line">		if(L&lt;&#x3D;mid)&#x2F;&#x2F;如果在左半只</span><br><span class="line">		re&#x3D;min(re,qh(k*2,l,mid,L,R));</span><br><span class="line">		if(R&gt;mid)&#x2F;&#x2F;如果在右半只</span><br><span class="line">		re&#x3D;min(re,qh(k*2+1,mid+1,r,L,R));</span><br><span class="line">		return re;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>求和求和查询：</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">int query(int ls,int rs,int l,int r,int p)</span><br><span class="line">&#123;</span><br><span class="line">	if(rs&lt;l||r&lt;ls)</span><br><span class="line">	&#123;</span><br><span class="line">		return 0;</span><br><span class="line">	&#125;</span><br><span class="line">	if(ls&lt;&#x3D;l&amp;&amp;r&lt;&#x3D;rs) </span><br><span class="line">	&#123;</span><br><span class="line">		return sum[p];</span><br><span class="line">	&#125;</span><br><span class="line">	pushdown(p,l,r);</span><br><span class="line">	int mid&#x3D;(l+r)&#x2F;2;</span><br><span class="line">	return query(ls,rs,l,mid,p*2)+query(ls,rs,mid+1,r,p*2+1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p>最后来看一看这道题：</p>
<blockquote>
<p>如果我们可以在数列[l,r]位置中改动至多一个数使得它们的最大公约数是x，那么这个猜测就被认为是接近正确的(注意我们不需要在数列中进行实际的改动)。</p>
</blockquote>
<p>题目说，我们可以改动一个数，那么我们来想想，我们该一个数，那么肯定是将这个数改为其他所有数的最大公约数，因为这样，我们才能使尽量少改数。</p>
<p>那么也就是说，如果只有其中的一个数不符合，那么我们就只改它一个就可以了，如果多于一个就需要输出NO。</p>
<p>那么我们就可以求在搜索过程中找有几个数不能被整除，如果大于一，说名我们需要改不知一个数，才能是x为其最大公约数。如果小于等于一，则说明我只需要改一个数或者不改，就能是使大公约数为x。</p>
<p>下面上代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;bits&#x2F;stdc++.h&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">inline int read()</span><br><span class="line">&#123;</span><br><span class="line">    int x&#x3D;0,f&#x3D;1;</span><br><span class="line">    char ch&#x3D;getchar();</span><br><span class="line">    while(ch&lt;&#39;0&#39;||ch&gt;&#39;9&#39;)</span><br><span class="line">    &#123;</span><br><span class="line">        if(ch&#x3D;&#x3D;&#39;-&#39;)</span><br><span class="line">        f&#x3D;-1;</span><br><span class="line">        ch&#x3D;getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    while(ch&gt;&#x3D;&#39;0&#39;&amp;&amp;ch&lt;&#x3D;&#39;9&#39;)</span><br><span class="line">    &#123;</span><br><span class="line">        x&#x3D;(x&lt;&lt;1)+(x&lt;&lt;3)+(ch^48);</span><br><span class="line">        ch&#x3D;getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    return x*f;</span><br><span class="line">&#125;</span><br><span class="line">int n,m,a[500005],sum[500005&lt;&lt;2];</span><br><span class="line">int q,b,c,d,tot;</span><br><span class="line">int zd(int x,int y) &#x2F;&#x2F;求最大公约数</span><br><span class="line">&#123;</span><br><span class="line">    return y?zd(y,x%y):x;</span><br><span class="line">&#125;</span><br><span class="line">void pushup(int k)&#x2F;&#x2F;将父亲节点的sum转化为子节点的最大公约数</span><br><span class="line">&#123;</span><br><span class="line">	sum[k]&#x3D;zd(sum[k&lt;&lt;1],sum[k&lt;&lt;1|1]);</span><br><span class="line">&#125;</span><br><span class="line">void build(int k,int l,int r)&#x2F;&#x2F;建树</span><br><span class="line">&#123;</span><br><span class="line">	if(l&#x3D;&#x3D;r)</span><br><span class="line">	&#123;</span><br><span class="line">		sum[k]&#x3D;a[l];</span><br><span class="line">		return ;</span><br><span class="line">	&#125;</span><br><span class="line">	int m&#x3D;(l+r)&gt;&gt;1;</span><br><span class="line">	build(k&lt;&lt;1,l,m);</span><br><span class="line">	build(k&lt;&lt;1|1,m+1,r);</span><br><span class="line">	pushup(k);</span><br><span class="line">&#125;</span><br><span class="line">void jia(int b,int c,int l,int r,int k)&#x2F;&#x2F;节点加和</span><br><span class="line">&#123;</span><br><span class="line">	if(l&#x3D;&#x3D;r&amp;&amp;r&#x3D;&#x3D;b)如果搜到b则将值更改为c</span><br><span class="line">	&#123;</span><br><span class="line">		sum[k]&#x3D;c;</span><br><span class="line">		return ;</span><br><span class="line">	&#125;</span><br><span class="line">	int m&#x3D;(l+r)&gt;&gt;1;</span><br><span class="line">	if(b&lt;&#x3D;m)&#x2F;&#x2F;如果在左半只，搜索左半只</span><br><span class="line">	&#123;</span><br><span class="line">		jia(b,c,l,m,k&lt;&lt;1);</span><br><span class="line">	&#125;</span><br><span class="line">	else&#x2F;&#x2F;如果在右半只，搜索右半只</span><br><span class="line">	&#123;</span><br><span class="line">		jia(b,c,m+1,r,k&lt;&lt;1|1);</span><br><span class="line">	&#125;</span><br><span class="line">	pushup(k);&#x2F;&#x2F;更新父节点sum</span><br><span class="line">&#125;</span><br><span class="line">void pd(int b,int c,int d,int l,int r,int k)</span><br><span class="line">&#123;</span><br><span class="line">	if(tot&gt;1) return ;&#x2F;&#x2F;一个小小的一优化，否则会TLE</span><br><span class="line">	if(l&#x3D;&#x3D;r) </span><br><span class="line">	&#123;</span><br><span class="line">		tot++;</span><br><span class="line">		return ;</span><br><span class="line">	&#125;</span><br><span class="line">	int m&#x3D;(l+r)&gt;&gt;1;</span><br><span class="line">	if(b&lt;&#x3D;m&amp;&amp;sum[k&lt;&lt;1]%d!&#x3D;0)&#x2F;&#x2F;如果有无法整除的数，也就是但前最大公约数不符合，就继续往下搜索，判断需要改几个</span><br><span class="line">	&#123;</span><br><span class="line">		pd(b,c,d,l,m,k&lt;&lt;1);</span><br><span class="line">	&#125;</span><br><span class="line">	if(c&gt;m&amp;&amp;sum[k&lt;&lt;1|1]%d!&#x3D;0)</span><br><span class="line">	&#123;</span><br><span class="line">		pd(b,c,d,m+1,r,k&lt;&lt;1|1);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	n&#x3D;read();</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;n;i++) a[i]&#x3D;read();</span><br><span class="line">	build(1,1,n);</span><br><span class="line">	m&#x3D;read();</span><br><span class="line">	for(int i&#x3D;1;i&lt;&#x3D;m;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		q&#x3D;read();</span><br><span class="line">		if(q&#x3D;&#x3D;2)</span><br><span class="line">		&#123;</span><br><span class="line">			b&#x3D;read();c&#x3D;read();</span><br><span class="line">			jia(b,c,1,n,1);</span><br><span class="line">		&#125;</span><br><span class="line">		else</span><br><span class="line">		&#123;</span><br><span class="line">			b&#x3D;read();c&#x3D;read();d&#x3D;read();</span><br><span class="line">			tot&#x3D;0;</span><br><span class="line">			pd(b,c,d,1,n,1);</span><br><span class="line">			if(tot&gt;1)</span><br><span class="line">			puts(&quot;NO&quot;);</span><br><span class="line">			else puts(&quot;YES&quot;);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

  </section>

  <section class="post-comments">

    <!-- 将评论系统（例如Disqus、多说、友言、畅言等）提供的代码片段粘贴在这里 -->
    
</section>


</article>


            <footer class="footer">

    <span class="footer__copyright">&copy; 2014-2015. | 由<a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>强力驱动 | 主题<a href="https://github.com/someus/huno" target="_blank" rel="noopener">Huno</a></span>
    
</footer>
        </div>
    </div>

    <!-- js files -->
    <script src="/js/jquery.min.js"></script>
    <script src="/js/main.js"></script>
    <script src="/js/scale.fix.js"></script>
    

    

    <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript"> 
        $(document).ready(function(){
            MathJax.Hub.Config({ 
                tex2jax: {inlineMath: [['[latex]','[/latex]'], ['\\(','\\)']]} 
            });
        });
    </script>


    

    <script src="/js/jquery.min.js"></script>
    <script src="/js/awesome-toc.min.js"></script>
    <script>
        $(document).ready(function(){
            $.awesome_toc({
                overlay: true,
                contentId: "post-content",
            });
        });
    </script>


    
    
    <!--kill ie6 -->
<!--[if IE 6]>
  <script src="//letskillie6.googlecode.com/svn/trunk/2/zh_CN.js"></script>
<![endif]-->

</body>
</html>
